[
["chapter-dbms-queries-intro.html", "Chapter 7 Introduction to DBMS queries 7.1 Setup 7.2 Downloading a single table 7.3 Mixing dplyr and SQL 7.4 Examining a single table with R 7.5 Additional reading", " Chapter 7 Introduction to DBMS queries This chapter demonstrates how to: Get a glimpse of what tables are in the database and what fields a table contains Download all or part of a table from the dbms See how dplyr code is translated into SQL commands Get acquainted with some useful tools for investigating a single table Begin thinking about how to divide the work between your local R session and the dbms 7.1 Setup The following packages are used in this chapter: library(tidyverse) library(DBI) library(RPostgres) library(dbplyr) require(knitr) library(bookdown) library(sqlpetr) Assume that the Docker container with PostgreSQL and the adventureworks database are ready to go. If not go back to [Chapter 6][#chapter_setup-adventureworks-db] sqlpetr::sp_docker_start(&quot;adventureworks&quot;) Connect to the database: con &lt;- sqlpetr::sp_get_postgres_connection( user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;adventureworks&quot;, port = 5432, seconds_to_test = 20, connection_tab = TRUE ) 7.2 Downloading a single table For the moment, assume you know something about the database and specifically what table you need to retrieve. 7.2.1 Downloading the entire table There are many different methods of getting data from a DBMS, and we’ll explore the different ways of controlling each one of them. DBI::dbReadTable will download an entire table into an R tibble. dbExecute(con, &quot;set search_path to sales, humanresources;&quot;) # watch for duplicates! ## [1] 0 salesorderheader_tibble &lt;- DBI::dbReadTable(con, &quot;salesorderheader&quot;) str(salesorderheader_tibble) ## &#39;data.frame&#39;: 31465 obs. of 25 variables: ## $ salesorderid : int 43659 43660 43661 43662 43663 43664 43665 43666 43667 43668 ... ## $ revisionnumber : int 8 8 8 8 8 8 8 8 8 8 ... ## $ orderdate : POSIXct, format: &quot;2011-05-31&quot; &quot;2011-05-31&quot; ... ## $ duedate : POSIXct, format: &quot;2011-06-12&quot; &quot;2011-06-12&quot; ... ## $ shipdate : POSIXct, format: &quot;2011-06-07&quot; &quot;2011-06-07&quot; ... ## $ status : int 5 5 5 5 5 5 5 5 5 5 ... ## $ onlineorderflag : logi FALSE FALSE FALSE FALSE FALSE FALSE ... ## $ purchaseordernumber : chr &quot;PO522145787&quot; &quot;PO18850127500&quot; &quot;PO18473189620&quot; &quot;PO18444174044&quot; ... ## $ accountnumber : chr &quot;10-4020-000676&quot; &quot;10-4020-000117&quot; &quot;10-4020-000442&quot; &quot;10-4020-000227&quot; ... ## $ customerid : int 29825 29672 29734 29994 29565 29898 29580 30052 29974 29614 ... ## $ salespersonid : int 279 279 282 282 276 280 283 276 277 282 ... ## $ territoryid : int 5 5 6 6 4 1 1 4 3 6 ... ## $ billtoaddressid : int 985 921 517 482 1073 876 849 1074 629 529 ... ## $ shiptoaddressid : int 985 921 517 482 1073 876 849 1074 629 529 ... ## $ shipmethodid : int 5 5 5 5 5 5 5 5 5 5 ... ## $ creditcardid : int 16281 5618 1346 10456 4322 806 15232 13349 10370 1566 ... ## $ creditcardapprovalcode: chr &quot;105041Vi84182&quot; &quot;115213Vi29411&quot; &quot;85274Vi6854&quot; &quot;125295Vi53935&quot; ... ## $ currencyrateid : int NA NA 4 4 NA NA NA NA NA 4 ... ## $ subtotal : num 20566 1294 32726 28833 419 ... ## $ taxamt : num 1971.5 124.2 3153.8 2775.2 40.3 ... ## $ freight : num 616.1 38.8 985.6 867.2 12.6 ... ## $ totaldue : num 23153 1457 36866 32475 472 ... ## $ comment : chr NA NA NA NA ... ## $ rowguid : chr &quot;79b65321-39ca-4115-9cba-8fe0903e12e6&quot; &quot;738dc42d-d03b-48a1-9822-f95a67ea7389&quot; &quot;d91b9131-18a4-4a11-bc3a-90b6f53e9d74&quot; &quot;4a1ecfc0-cc3a-4740-b028-1c50bb48711c&quot; ... ## $ modifieddate : POSIXct, format: &quot;2011-06-07&quot; &quot;2011-06-07&quot; ... That’s very simple, but if the table is large it may not be a good idea, since R is designed to keep the entire table in memory. Note that the first line of the str() output reports the total number of observations. 7.2.2 A table object that can be reused The dplyr::tbl function gives us more control over access to a table by enabling control over which columns and rows to download. It creates an object that might look like a data frame, but it’s actually a list object that dplyr uses for constructing queries and retrieving data from the DBMS. salesorderheader_table &lt;- dplyr::tbl(con, &quot;salesorderheader&quot;) class(salesorderheader_table) ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; ## [4] &quot;tbl_lazy&quot; &quot;tbl&quot; 7.2.3 Controlling the number of rows returned The collect function triggers the creation of a tibble and controls the number of rows that the DBMS sends to R. For more complex queries, the dplyr::collect() function provides a mechanism to indicate what’s processed on on the dbms server and what’s processed by R on the local machine. The chapter on Lazy Evaluation and Execution Environment discusses this issue in detail. salesorderheader_table %&gt;% dplyr::collect(n = 3) %&gt;% dim ## [1] 3 25 salesorderheader_table %&gt;% dplyr::collect(n = 500) %&gt;% dim ## [1] 500 25 7.2.4 Random rows from the dbms When the dbms contains many rows, a sample of the data may be plenty for your purposes. Although dplyr has nice functions to sample a data frame that’s already in R (e.g., the sample_n and sample_frac functions), to get a sample from the dbms we have to use dbGetQuery to send native SQL to the database. To peek ahead, here is one example of a query that retrieves 20 rows from a 1% sample: one_percent_sample &lt;- DBI::dbGetQuery( con, &quot;SELECT orderdate, subtotal, taxamt, freight, totaldue FROM salesorderheader TABLESAMPLE BERNOULLI(3) LIMIT 20; &quot; ) one_percent_sample ## orderdate subtotal taxamt freight totaldue ## 1 2011-06-05 3578.2700 286.2616 89.4568 3953.9884 ## 2 2011-06-18 699.0982 55.9279 17.4775 772.5036 ## 3 2011-06-21 3399.9900 271.9992 84.9998 3756.9890 ## 4 2011-06-24 699.0982 55.9279 17.4775 772.5036 ## 5 2011-06-27 3578.2700 286.2616 89.4568 3953.9884 ## 6 2011-07-01 2082.6748 199.3984 62.3120 2344.3852 ## 7 2011-07-01 36724.0974 3522.2975 1100.7180 41347.1129 ## 8 2011-07-03 3578.2700 286.2616 89.4568 3953.9884 ## 9 2011-07-07 3578.2700 286.2616 89.4568 3953.9884 ## 10 2011-07-12 3578.2700 286.2616 89.4568 3953.9884 ## 11 2011-07-18 3374.9900 269.9992 84.3748 3729.3640 ## 12 2011-07-21 3374.9900 269.9992 84.3748 3729.3640 ## 13 2011-07-27 3578.2700 286.2616 89.4568 3953.9884 ## 14 2011-07-29 3578.2700 286.2616 89.4568 3953.9884 ## 15 2011-08-01 28045.3358 2702.1800 844.4313 31591.9471 ## 16 2011-08-01 2039.9940 195.8394 61.1998 2297.0332 ## 17 2011-08-01 73761.5266 7108.6377 2221.4493 83091.6136 ## 18 2011-08-01 8129.9760 780.4777 243.8993 9154.3530 ## 19 2011-08-01 12907.7717 1241.5408 387.9815 14537.2940 ## 20 2011-08-01 3427.4236 329.0327 102.8227 3859.2790 Exact sample of 100 records This technique depends on knowing the range of a record index, such as the businessentityid in the salesorderheader table of our adventureworks database. Start by finding the min and max values. DBI::dbListFields(con, &quot;salesorderheader&quot;) ## [1] &quot;salesorderid&quot; &quot;revisionnumber&quot; ## [3] &quot;orderdate&quot; &quot;duedate&quot; ## [5] &quot;shipdate&quot; &quot;status&quot; ## [7] &quot;onlineorderflag&quot; &quot;purchaseordernumber&quot; ## [9] &quot;accountnumber&quot; &quot;customerid&quot; ## [11] &quot;salespersonid&quot; &quot;territoryid&quot; ## [13] &quot;billtoaddressid&quot; &quot;shiptoaddressid&quot; ## [15] &quot;shipmethodid&quot; &quot;creditcardid&quot; ## [17] &quot;creditcardapprovalcode&quot; &quot;currencyrateid&quot; ## [19] &quot;subtotal&quot; &quot;taxamt&quot; ## [21] &quot;freight&quot; &quot;totaldue&quot; ## [23] &quot;comment&quot; &quot;rowguid&quot; ## [25] &quot;modifieddate&quot; salesorderheader_df &lt;- DBI::dbReadTable(con, &quot;salesorderheader&quot;) (max_id &lt;- max(salesorderheader_df$salesorderid)) ## [1] 75123 (min_id &lt;- min(salesorderheader_df$salesorderid)) ## [1] 43659 Set the random number seed and draw the sample. set.seed(123) sample_rows &lt;- sample(1:max(salesorderheader_df$salesorderid), 10) salesorderheader_table &lt;- dplyr::tbl(con, &quot;salesorderheader&quot;) Run query with the filter verb listing the randomly sampled rows to be retrieved: salesorderheader_sample &lt;- salesorderheader_table %&gt;% dplyr::filter(salesorderid %in% sample_rows) %&gt;% dplyr::collect() str(salesorderheader_sample) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 7 obs. of 25 variables: ## $ salesorderid : int 45404 46435 51663 57870 62555 65161 68293 ## $ revisionnumber : int 8 8 8 8 8 8 8 ## $ orderdate : POSIXct, format: &quot;2012-01-10&quot; &quot;2012-05-06&quot; ... ## $ duedate : POSIXct, format: &quot;2012-01-22&quot; &quot;2012-05-18&quot; ... ## $ shipdate : POSIXct, format: &quot;2012-01-17&quot; &quot;2012-05-13&quot; ... ## $ status : int 5 5 5 5 5 5 5 ## $ onlineorderflag : logi TRUE TRUE TRUE TRUE TRUE FALSE ... ## $ purchaseordernumber : chr NA NA NA NA ... ## $ accountnumber : chr &quot;10-4030-011217&quot; &quot;10-4030-012251&quot; &quot;10-4030-016327&quot; &quot;10-4030-018572&quot; ... ## $ customerid : int 11217 12251 16327 18572 13483 29799 13239 ## $ salespersonid : int NA NA NA NA NA 281 NA ## $ territoryid : int 1 9 8 4 1 4 6 ## $ billtoaddressid : int 19321 24859 19265 16902 15267 997 27923 ## $ shiptoaddressid : int 19321 24859 19265 16902 15267 997 27923 ## $ shipmethodid : int 1 1 1 1 1 5 1 ## $ creditcardid : int 8241 13188 16357 1884 4409 12582 1529 ## $ creditcardapprovalcode: chr &quot;332581Vi42712&quot; &quot;635144Vi68383&quot; &quot;420152Vi84562&quot; &quot;1224478Vi9772&quot; ... ## $ currencyrateid : int NA 4121 NA NA NA NA 11581 ## $ subtotal : num 3578 3375 2466 14 57 ... ## $ taxamt : num 286.26 270 197.31 1.12 4.56 ... ## $ freight : num 89.457 84.375 61.658 0.349 1.424 ... ## $ totaldue : num 3954 3729.4 2725.3 15.4 63 ... ## $ comment : chr NA NA NA NA ... ## $ rowguid : chr &quot;358f91b2-dadd-4014-8d4f-7f9736cb664e&quot; &quot;eb312409-fcd5-4bac-bd3b-16d4bd7889db&quot; &quot;ddc60552-af98-4166-9249-d09d424d8430&quot; &quot;fe46e631-47b9-4e14-9da5-1e4a4a135364&quot; ... ## $ modifieddate : POSIXct, format: &quot;2012-01-17&quot; &quot;2012-05-13&quot; ... 7.2.5 Sub-setting variables A table in the dbms may not only have many more rows than you want, but also many more columns. The select command controls which columns are retrieved. salesorderheader_table %&gt;% dplyr::select(orderdate, subtotal, taxamt, freight, totaldue) %&gt;% head() ## # Source: lazy query [?? x 5] ## # Database: postgres [postgres@localhost:5432/adventureworks] ## orderdate subtotal taxamt freight totaldue ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2011-05-31 00:00:00 20566. 1972. 616. 23153. ## 2 2011-05-31 00:00:00 1294. 124. 38.8 1457. ## 3 2011-05-31 00:00:00 32726. 3154. 986. 36866. ## 4 2011-05-31 00:00:00 28833. 2775. 867. 32475. ## 5 2011-05-31 00:00:00 419. 40.3 12.6 472. ## 6 2011-05-31 00:00:00 24433. 2345. 733. 27510. That’s exactly equivalent to submitting the following SQL commands dirctly: DBI::dbGetQuery( con, &#39;SELECT &quot;orderdate&quot;, &quot;subtotal&quot;, &quot;taxamt&quot;, &quot;freight&quot;, &quot;totaldue&quot; FROM &quot;salesorderheader&quot; LIMIT 6&#39;) ## orderdate subtotal taxamt freight totaldue ## 1 2011-05-31 20565.6206 1971.5149 616.0984 23153.2339 ## 2 2011-05-31 1294.2529 124.2483 38.8276 1457.3288 ## 3 2011-05-31 32726.4786 3153.7696 985.5530 36865.8012 ## 4 2011-05-31 28832.5289 2775.1646 867.2389 32474.9324 ## 5 2011-05-31 419.4589 40.2681 12.5838 472.3108 ## 6 2011-05-31 24432.6088 2344.9921 732.8100 27510.4109 We won’t discuss dplyr methods for sub-setting variables, deriving new ones, or sub-setting rows based on the values found in the table, because they are covered well in other places, including: Comprehensive reference: https://dplyr.tidyverse.org/ Good tutorial: https://suzan.rbind.io/tags/dplyr/ In practice we find that, renaming variables is often quite important because the names in an SQL database might not meet your needs as an analyst. In “the wild”, you will find names that are ambiguous or overly specified, with spaces in them, and other problems that will make them difficult to use in R. It is good practice to do whatever renaming you are going to do in a predictable place like at the top of your code. The names in the adventureworks database are simple and clear, but if they were not, you might rename them for subsequent use in this way: tbl(con, &quot;salesorderheader&quot;) %&gt;% dplyr::rename(order_date = orderdate, sub_total_amount = subtotal, tax_amount = taxamt, freight_amount = freight, total_due_amount = totaldue) %&gt;% dplyr::select(order_date, sub_total_amount, tax_amount, freight_amount, total_due_amount ) %&gt;% # head() show_query() ## &lt;SQL&gt; ## SELECT &quot;orderdate&quot; AS &quot;order_date&quot;, &quot;subtotal&quot; AS &quot;sub_total_amount&quot;, &quot;taxamt&quot; AS &quot;tax_amount&quot;, &quot;freight&quot; AS &quot;freight_amount&quot;, &quot;totaldue&quot; AS &quot;total_due_amount&quot; ## FROM &quot;salesorderheader&quot; That’s equivalent to the following SQL code: DBI::dbGetQuery( con, &#39;SELECT &quot;orderdate&quot; AS &quot;order_date&quot;, &quot;subtotal&quot; AS &quot;sub_total_amount&quot;, &quot;taxamt&quot; AS &quot;tax_amount&quot;, &quot;freight&quot; AS &quot;freight_amount&quot;, &quot;totaldue&quot; AS &quot;total_due_amount&quot; FROM &quot;salesorderheader&quot;&#39; ) %&gt;% head() ## order_date sub_total_amount tax_amount freight_amount total_due_amount ## 1 2011-05-31 20565.6206 1971.5149 616.0984 23153.2339 ## 2 2011-05-31 1294.2529 124.2483 38.8276 1457.3288 ## 3 2011-05-31 32726.4786 3153.7696 985.5530 36865.8012 ## 4 2011-05-31 28832.5289 2775.1646 867.2389 32474.9324 ## 5 2011-05-31 419.4589 40.2681 12.5838 472.3108 ## 6 2011-05-31 24432.6088 2344.9921 732.8100 27510.4109 The one difference is that the SQL code returns a regular data frame and the dplyr code returns a tibble. Notice that the seconds are greyed out in the tibble display. 7.2.6 Translating dplyr code to SQL queries Where did the translations we’ve shown above come from? The show_query function shows how dplyr is translating your query to the dialect of the target dbms: salesorderheader_table %&gt;% dplyr::tally() %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT COUNT(*) AS &quot;n&quot; ## FROM &quot;salesorderheader&quot; Here is an extensive discussion of how dplyr code is translated into SQL: https://dbplyr.tidyverse.org/articles/sql-translation.html If you prefer to use SQL directly, rather than dplyr, you can submit SQL code to the DBMS through the DBI::dbGetQuery function: DBI::dbGetQuery( con, &#39;SELECT COUNT(*) AS &quot;n&quot; FROM &quot;salesorderheader&quot; &#39; ) ## n ## 1 31465 When you create a report to run repeatedly, you might want to put that query into R markdown. That way you can also execute that SQL code in a chunk with the following header: {sql, connection=con, output.var = &quot;query_results&quot;} SELECT COUNT(*) AS &quot;n&quot; FROM &quot;salesorderheader&quot;; Rmarkdown stores that query result in a tibble which can be printed by referring to it: query_results ## n ## 1 31465 7.3 Mixing dplyr and SQL When dplyr finds code that it does not know how to translate into SQL, it will simply pass it along to the dbms. Therefore you can interleave native commands that your dbms will understand in the middle of dplyr code. Consider this example that’s derived from (Ruiz 2019): salesorderheader_table %&gt;% dplyr::select_at(vars(subtotal, contains(&quot;date&quot;))) %&gt;% dplyr::mutate(today = now()) %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT &quot;subtotal&quot;, &quot;orderdate&quot;, &quot;duedate&quot;, &quot;shipdate&quot;, &quot;modifieddate&quot;, CURRENT_TIMESTAMP AS &quot;today&quot; ## FROM &quot;salesorderheader&quot; That is native to PostgreSQL, not ANSI standard SQL. Verify that it works: salesorderheader_table %&gt;% dplyr::select_at(vars(subtotal, contains(&quot;date&quot;))) %&gt;% head() %&gt;% dplyr::mutate(today = now()) %&gt;% dplyr::collect() ## # A tibble: 6 x 6 ## subtotal orderdate duedate shipdate ## &lt;dbl&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dttm&gt; ## 1 20566. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 2 1294. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 3 32726. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 4 28833. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 5 419. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 6 24433. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## # … with 2 more variables: modifieddate &lt;dttm&gt;, today &lt;dttm&gt; 7.4 Examining a single table with R Dealing with a large, complex database highlights the utility of specific tools in R. We include brief examples that we find to be handy: Base R structure: str Printing out some of the data: datatable, kable, and View Summary statistics: summary glimpse in the tibble package, which is included in the tidyverse skim in the skimr package 7.4.1 str - a base package workhorse str is a workhorse function that lists variables, their type and a sample of the first few variable values. str(salesorderheader_tibble) ## &#39;data.frame&#39;: 31465 obs. of 25 variables: ## $ salesorderid : int 43659 43660 43661 43662 43663 43664 43665 43666 43667 43668 ... ## $ revisionnumber : int 8 8 8 8 8 8 8 8 8 8 ... ## $ orderdate : POSIXct, format: &quot;2011-05-31&quot; &quot;2011-05-31&quot; ... ## $ duedate : POSIXct, format: &quot;2011-06-12&quot; &quot;2011-06-12&quot; ... ## $ shipdate : POSIXct, format: &quot;2011-06-07&quot; &quot;2011-06-07&quot; ... ## $ status : int 5 5 5 5 5 5 5 5 5 5 ... ## $ onlineorderflag : logi FALSE FALSE FALSE FALSE FALSE FALSE ... ## $ purchaseordernumber : chr &quot;PO522145787&quot; &quot;PO18850127500&quot; &quot;PO18473189620&quot; &quot;PO18444174044&quot; ... ## $ accountnumber : chr &quot;10-4020-000676&quot; &quot;10-4020-000117&quot; &quot;10-4020-000442&quot; &quot;10-4020-000227&quot; ... ## $ customerid : int 29825 29672 29734 29994 29565 29898 29580 30052 29974 29614 ... ## $ salespersonid : int 279 279 282 282 276 280 283 276 277 282 ... ## $ territoryid : int 5 5 6 6 4 1 1 4 3 6 ... ## $ billtoaddressid : int 985 921 517 482 1073 876 849 1074 629 529 ... ## $ shiptoaddressid : int 985 921 517 482 1073 876 849 1074 629 529 ... ## $ shipmethodid : int 5 5 5 5 5 5 5 5 5 5 ... ## $ creditcardid : int 16281 5618 1346 10456 4322 806 15232 13349 10370 1566 ... ## $ creditcardapprovalcode: chr &quot;105041Vi84182&quot; &quot;115213Vi29411&quot; &quot;85274Vi6854&quot; &quot;125295Vi53935&quot; ... ## $ currencyrateid : int NA NA 4 4 NA NA NA NA NA 4 ... ## $ subtotal : num 20566 1294 32726 28833 419 ... ## $ taxamt : num 1971.5 124.2 3153.8 2775.2 40.3 ... ## $ freight : num 616.1 38.8 985.6 867.2 12.6 ... ## $ totaldue : num 23153 1457 36866 32475 472 ... ## $ comment : chr NA NA NA NA ... ## $ rowguid : chr &quot;79b65321-39ca-4115-9cba-8fe0903e12e6&quot; &quot;738dc42d-d03b-48a1-9822-f95a67ea7389&quot; &quot;d91b9131-18a4-4a11-bc3a-90b6f53e9d74&quot; &quot;4a1ecfc0-cc3a-4740-b028-1c50bb48711c&quot; ... ## $ modifieddate : POSIXct, format: &quot;2011-06-07&quot; &quot;2011-06-07&quot; ... 7.4.2 Always look at your data with head, View, or kable There is no substitute for looking at your data and R provides several ways to just browse it. The head function controls the number of rows that are displayed. Note that tail does not work against a database object. In every-day practice you would look at more than the default 6 rows, but here we wrap head around the data frame: sqlpetr::sp_print_df(head(salesorderheader_tibble)) 7.4.3 The summary function in base The base package’s summary function provides basic statistics that serve a unique diagnostic purpose in this context. For example, the following output shows that: * `businessentityid` is a number from 1 to 16,049. In a previous section, we ran the `str` function and saw that there are 16,044 observations in this table. Therefore, the `businessentityid` seems to be sequential from 1:16049, but there are 5 values missing from that sequence. _Exercise for the Reader_: Which 5 values from 1:16049 are missing from `businessentityid` values in the `salesorderheader` table? (_Hint_: In the chapter on SQL Joins, you will learn the functions needed to answer this question.) * The number of NA&#39;s in the `return_date` column is a good first guess as to the number of DVDs rented out or lost as of 2005-09-02 02:35:22. summary(salesorderheader_tibble) ## salesorderid revisionnumber orderdate ## Min. :43659 Min. :8.000 Min. :2011-05-31 00:00:00 ## 1st Qu.:51525 1st Qu.:8.000 1st Qu.:2013-06-20 00:00:00 ## Median :59391 Median :8.000 Median :2013-11-03 00:00:00 ## Mean :59391 Mean :8.001 Mean :2013-08-21 12:05:04 ## 3rd Qu.:67257 3rd Qu.:8.000 3rd Qu.:2014-02-28 00:00:00 ## Max. :75123 Max. :9.000 Max. :2014-06-30 00:00:00 ## ## duedate shipdate status ## Min. :2011-06-12 00:00:00 Min. :2011-06-07 00:00:00 Min. :5 ## 1st Qu.:2013-07-02 00:00:00 1st Qu.:2013-06-27 00:00:00 1st Qu.:5 ## Median :2013-11-15 00:00:00 Median :2013-11-10 00:00:00 Median :5 ## Mean :2013-09-02 12:05:41 Mean :2013-08-28 12:06:06 Mean :5 ## 3rd Qu.:2014-03-13 00:00:00 3rd Qu.:2014-03-08 00:00:00 3rd Qu.:5 ## Max. :2014-07-12 00:00:00 Max. :2014-07-07 00:00:00 Max. :5 ## ## onlineorderflag purchaseordernumber accountnumber customerid ## Mode :logical Length:31465 Length:31465 Min. :11000 ## FALSE:3806 Class :character Class :character 1st Qu.:14432 ## TRUE :27659 Mode :character Mode :character Median :19452 ## Mean :20170 ## 3rd Qu.:25994 ## Max. :30118 ## ## salespersonid territoryid billtoaddressid shiptoaddressid ## Min. :274.0 Min. : 1.000 Min. : 405 Min. : 9 ## 1st Qu.:277.0 1st Qu.: 4.000 1st Qu.:14080 1st Qu.:14063 ## Median :279.0 Median : 6.000 Median :19449 Median :19438 ## Mean :280.6 Mean : 6.091 Mean :18263 Mean :18249 ## 3rd Qu.:284.0 3rd Qu.: 9.000 3rd Qu.:24678 3rd Qu.:24672 ## Max. :290.0 Max. :10.000 Max. :29883 Max. :29883 ## NA&#39;s :27659 ## shipmethodid creditcardid creditcardapprovalcode currencyrateid ## Min. :1.000 Min. : 1 Length:31465 Min. : 2 ## 1st Qu.:1.000 1st Qu.: 4894 Class :character 1st Qu.: 8510 ## Median :1.000 Median : 9720 Mode :character Median :10074 ## Mean :1.484 Mean : 9684 Mean : 9192 ## 3rd Qu.:1.000 3rd Qu.:14511 3rd Qu.:11282 ## Max. :5.000 Max. :19237 Max. :12431 ## NA&#39;s :1131 NA&#39;s :17489 ## subtotal taxamt freight ## Min. : 1.37 Min. : 0.110 Min. : 0.034 ## 1st Qu.: 56.97 1st Qu.: 4.558 1st Qu.: 1.424 ## Median : 782.99 Median : 62.639 Median : 19.575 ## Mean : 3491.07 Mean : 323.756 Mean : 101.174 ## 3rd Qu.: 2366.96 3rd Qu.: 189.598 3rd Qu.: 59.249 ## Max. :163930.39 Max. :17948.519 Max. :5608.912 ## ## totaldue comment rowguid ## Min. : 1.52 Length:31465 Length:31465 ## 1st Qu.: 62.95 Class :character Class :character ## Median : 865.20 Mode :character Mode :character ## Mean : 3916.00 ## 3rd Qu.: 2615.49 ## Max. :187487.83 ## ## modifieddate ## Min. :2011-06-07 00:00:00 ## 1st Qu.:2013-06-27 00:00:00 ## Median :2013-11-10 00:00:00 ## Mean :2013-08-28 12:06:06 ## 3rd Qu.:2014-03-08 00:00:00 ## Max. :2014-07-07 00:00:00 ## So the summary function is surprisingly useful as we first start to look at the table contents. 7.4.4 The glimpse function in the tibble package The tibble package’s glimpse function is a more compact version of str: tibble::glimpse(salesorderheader_tibble) ## Observations: 31,465 ## Variables: 25 ## $ salesorderid &lt;int&gt; 43659, 43660, 43661, 43662, 43663, 43664,… ## $ revisionnumber &lt;int&gt; 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,… ## $ orderdate &lt;dttm&gt; 2011-05-31, 2011-05-31, 2011-05-31, 2011… ## $ duedate &lt;dttm&gt; 2011-06-12, 2011-06-12, 2011-06-12, 2011… ## $ shipdate &lt;dttm&gt; 2011-06-07, 2011-06-07, 2011-06-07, 2011… ## $ status &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… ## $ onlineorderflag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,… ## $ purchaseordernumber &lt;chr&gt; &quot;PO522145787&quot;, &quot;PO18850127500&quot;, &quot;PO184731… ## $ accountnumber &lt;chr&gt; &quot;10-4020-000676&quot;, &quot;10-4020-000117&quot;, &quot;10-4… ## $ customerid &lt;int&gt; 29825, 29672, 29734, 29994, 29565, 29898,… ## $ salespersonid &lt;int&gt; 279, 279, 282, 282, 276, 280, 283, 276, 2… ## $ territoryid &lt;int&gt; 5, 5, 6, 6, 4, 1, 1, 4, 3, 6, 1, 3, 1, 6,… ## $ billtoaddressid &lt;int&gt; 985, 921, 517, 482, 1073, 876, 849, 1074,… ## $ shiptoaddressid &lt;int&gt; 985, 921, 517, 482, 1073, 876, 849, 1074,… ## $ shipmethodid &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… ## $ creditcardid &lt;int&gt; 16281, 5618, 1346, 10456, 4322, 806, 1523… ## $ creditcardapprovalcode &lt;chr&gt; &quot;105041Vi84182&quot;, &quot;115213Vi29411&quot;, &quot;85274V… ## $ currencyrateid &lt;int&gt; NA, NA, 4, 4, NA, NA, NA, NA, NA, 4, NA, … ## $ subtotal &lt;dbl&gt; 20565.6206, 1294.2529, 32726.4786, 28832.… ## $ taxamt &lt;dbl&gt; 1971.5149, 124.2483, 3153.7696, 2775.1646… ## $ freight &lt;dbl&gt; 616.0984, 38.8276, 985.5530, 867.2389, 12… ## $ totaldue &lt;dbl&gt; 23153.2339, 1457.3288, 36865.8012, 32474.… ## $ comment &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ rowguid &lt;chr&gt; &quot;79b65321-39ca-4115-9cba-8fe0903e12e6&quot;, &quot;… ## $ modifieddate &lt;dttm&gt; 2011-06-07, 2011-06-07, 2011-06-07, 2011… 7.4.5 The skim function in the skimr package The skimr package has several functions that make it easy to examine an unknown data frame and assess what it contains. It is also extensible. library(skimr) ## ## Attaching package: &#39;skimr&#39; ## The following object is masked from &#39;package:knitr&#39;: ## ## kable ## The following object is masked from &#39;package:stats&#39;: ## ## filter skimr::skim(salesorderheader_tibble) ## Skim summary statistics ## n obs: 31465 ## n variables: 25 ## ## ── Variable type:character ────────────────────────────────────────────────────────────────────────────────────────────── ## variable missing complete n min max empty n_unique ## accountnumber 0 31465 31465 14 14 0 19119 ## comment 31465 0 31465 NA NA 0 0 ## creditcardapprovalcode 1131 30334 31465 9 15 0 30334 ## purchaseordernumber 27659 3806 31465 10 13 0 3806 ## rowguid 0 31465 31465 36 36 0 31465 ## ## ── Variable type:integer ──────────────────────────────────────────────────────────────────────────────────────────────── ## variable missing complete n mean sd p0 p25 ## billtoaddressid 0 31465 31465 18263.15 8210.07 405 14080 ## creditcardid 1131 30334 31465 9684.1 5566.3 1 4894.25 ## currencyrateid 17489 13976 31465 9191.5 2945.17 2 8510 ## customerid 0 31465 31465 20170.18 6261.73 11000 14432 ## revisionnumber 0 31465 31465 8 0.031 8 8 ## salesorderid 0 31465 31465 59391 9083.31 43659 51525 ## salespersonid 27659 3806 31465 280.61 4.85 274 277 ## shipmethodid 0 31465 31465 1.48 1.3 1 1 ## shiptoaddressid 0 31465 31465 18249.19 8218.43 9 14063 ## status 0 31465 31465 5 0 5 5 ## territoryid 0 31465 31465 6.09 2.96 1 4 ## p50 p75 p100 hist ## 19449 24678 29883 ▆▁▁▇▇▇▇▇ ## 9719.5 14510.75 19237 ▇▇▇▇▇▇▇▇ ## 10074 11282 12431 ▁▁▁▁▂▃▇▇ ## 19452 25994 30118 ▇▆▅▅▃▃▅▇ ## 8 8 9 ▇▁▁▁▁▁▁▁ ## 59391 67257 75123 ▇▇▇▇▇▇▇▇ ## 279 284 290 ▇▆▅▅▃▁▂▅ ## 1 1 5 ▇▁▁▁▁▁▁▁ ## 19438 24672 29883 ▆▁▁▇▇▇▇▇ ## 5 5 5 ▁▁▁▇▁▁▁▁ ## 6 9 10 ▃▁▅▁▃▂▂▇ ## ## ── Variable type:logical ──────────────────────────────────────────────────────────────────────────────────────────────── ## variable missing complete n mean count ## onlineorderflag 0 31465 31465 0.88 TRU: 27659, FAL: 3806, NA: 0 ## ## ── Variable type:numeric ──────────────────────────────────────────────────────────────────────────────────────────────── ## variable missing complete n mean sd p0 p25 p50 ## freight 0 31465 31465 101.17 339.08 0.034 1.42 19.57 ## subtotal 0 31465 31465 3491.07 11093.45 1.37 56.97 782.99 ## taxamt 0 31465 31465 323.76 1085.05 0.11 4.56 62.64 ## totaldue 0 31465 31465 3916 12515.46 1.52 62.95 865.2 ## p75 p100 hist ## 59.25 5608.91 ▇▁▁▁▁▁▁▁ ## 2366.96 163930.39 ▇▁▁▁▁▁▁▁ ## 189.6 17948.52 ▇▁▁▁▁▁▁▁ ## 2615.49 187487.83 ▇▁▁▁▁▁▁▁ ## ## ── Variable type:POSIXct ──────────────────────────────────────────────────────────────────────────────────────────────── ## variable missing complete n min max median ## duedate 0 31465 31465 2011-06-12 2014-07-12 2013-11-15 ## modifieddate 0 31465 31465 2011-06-07 2014-07-07 2013-11-10 ## orderdate 0 31465 31465 2011-05-31 2014-06-30 2013-11-03 ## shipdate 0 31465 31465 2011-06-07 2014-07-07 2013-11-10 ## n_unique ## 1124 ## 1124 ## 1124 ## 1124 skimr::skim_to_wide(salesorderheader_tibble) #skimr doesn&#39;t like certain kinds of columns ## # A tibble: 25 x 19 ## type variable missing complete n min max empty n_unique mean ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 char… account… 0 31465 31465 14 14 0 19119 &lt;NA&gt; ## 2 char… comment 31465 0 31465 NA NA 0 0 &lt;NA&gt; ## 3 char… creditc… 1131 30334 31465 9 15 0 30334 &lt;NA&gt; ## 4 char… purchas… 27659 3806 31465 10 13 0 3806 &lt;NA&gt; ## 5 char… rowguid 0 31465 31465 36 36 0 31465 &lt;NA&gt; ## 6 inte… billtoa… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 1826… ## 7 inte… creditc… 1131 30334 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot; 96… ## 8 inte… currenc… 17489 13976 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot; 91… ## 9 inte… custome… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 2017… ## 10 inte… revisio… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot; … ## # … with 15 more rows, and 9 more variables: sd &lt;chr&gt;, p0 &lt;chr&gt;, ## # p25 &lt;chr&gt;, p50 &lt;chr&gt;, p75 &lt;chr&gt;, p100 &lt;chr&gt;, hist &lt;chr&gt;, count &lt;chr&gt;, ## # median &lt;chr&gt; 7.4.6 Close the connection and shut down adventureworks Where you place the collect function matters. DBI::dbDisconnect(con) sqlpetr::sp_docker_stop(&quot;adventureworks&quot;) 7.5 Additional reading (Wickham 2018) (Baumer 2018) References "]
]
