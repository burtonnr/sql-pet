[
["chapter-dbms-queries-intro.html", "Chapter 7 Introduction to DBMS queries 7.1 Setup 7.2 Methods for downloading a single table 7.3 Translating dplyr code to SQL queries 7.4 Mixing dplyr and SQL 7.5 Examining a single table with R 7.6 Additional reading", " Chapter 7 Introduction to DBMS queries This chapter demonstrates how to: Download all or part of a table from the DBMS, including different kinds of subsets See how dplyr code is translated into SQL commands and how they can be mixed Get acquainted with some useful functions and packages for investigating a single table Begin thinking about how to divide the work between your local R session and the DBMS 7.1 Setup The following packages are used in this chapter: library(tidyverse) library(DBI) library(RPostgres) library(dbplyr) require(knitr) library(bookdown) library(sqlpetr) library(skimr) Assume that the Docker container with PostgreSQL and the adventureworks database are ready to go. If not go back to [Chapter 6][#chapter_setup-adventureworks-db] sqlpetr::sp_docker_start(&quot;adventureworks&quot;) Connect to the database: con &lt;- sqlpetr::sp_get_postgres_connection( user = Sys.getenv(&quot;DEFAULT_POSTGRES_USER_NAME&quot;), password = Sys.getenv(&quot;DEFAULT_POSTGRES_PASSWORD&quot;), dbname = &quot;adventureworks&quot;, port = 5432, seconds_to_test = 20, connection_tab = TRUE ) 7.2 Methods for downloading a single table For the moment, assume you know something about the database and specifically what table you need to retrieve. We return to the topic of investigating the whole database later on. dbExecute(con, &quot;set search_path to sales, humanresources;&quot;) ## [1] 0 7.2.1 Read the entire table There are a few different methods of getting data from a DBMS, and we’ll explore the different ways of controlling each one of them. DBI::dbReadTable will download an entire table into an R tibble. salesorderheader_tibble &lt;- DBI::dbReadTable(con, &quot;salesorderheader&quot;) str(salesorderheader_tibble) ## &#39;data.frame&#39;: 31465 obs. of 25 variables: ## $ salesorderid : int 43659 43660 43661 43662 43663 43664 43665 43666 43667 43668 ... ## $ revisionnumber : int 8 8 8 8 8 8 8 8 8 8 ... ## $ orderdate : POSIXct, format: &quot;2011-05-31&quot; &quot;2011-05-31&quot; ... ## $ duedate : POSIXct, format: &quot;2011-06-12&quot; &quot;2011-06-12&quot; ... ## $ shipdate : POSIXct, format: &quot;2011-06-07&quot; &quot;2011-06-07&quot; ... ## $ status : int 5 5 5 5 5 5 5 5 5 5 ... ## $ onlineorderflag : logi FALSE FALSE FALSE FALSE FALSE FALSE ... ## $ purchaseordernumber : chr &quot;PO522145787&quot; &quot;PO18850127500&quot; &quot;PO18473189620&quot; &quot;PO18444174044&quot; ... ## $ accountnumber : chr &quot;10-4020-000676&quot; &quot;10-4020-000117&quot; &quot;10-4020-000442&quot; &quot;10-4020-000227&quot; ... ## $ customerid : int 29825 29672 29734 29994 29565 29898 29580 30052 29974 29614 ... ## $ salespersonid : int 279 279 282 282 276 280 283 276 277 282 ... ## $ territoryid : int 5 5 6 6 4 1 1 4 3 6 ... ## $ billtoaddressid : int 985 921 517 482 1073 876 849 1074 629 529 ... ## $ shiptoaddressid : int 985 921 517 482 1073 876 849 1074 629 529 ... ## $ shipmethodid : int 5 5 5 5 5 5 5 5 5 5 ... ## $ creditcardid : int 16281 5618 1346 10456 4322 806 15232 13349 10370 1566 ... ## $ creditcardapprovalcode: chr &quot;105041Vi84182&quot; &quot;115213Vi29411&quot; &quot;85274Vi6854&quot; &quot;125295Vi53935&quot; ... ## $ currencyrateid : int NA NA 4 4 NA NA NA NA NA 4 ... ## $ subtotal : num 20566 1294 32726 28833 419 ... ## $ taxamt : num 1971.5 124.2 3153.8 2775.2 40.3 ... ## $ freight : num 616.1 38.8 985.6 867.2 12.6 ... ## $ totaldue : num 23153 1457 36866 32475 472 ... ## $ comment : chr NA NA NA NA ... ## $ rowguid : chr &quot;79b65321-39ca-4115-9cba-8fe0903e12e6&quot; &quot;738dc42d-d03b-48a1-9822-f95a67ea7389&quot; &quot;d91b9131-18a4-4a11-bc3a-90b6f53e9d74&quot; &quot;4a1ecfc0-cc3a-4740-b028-1c50bb48711c&quot; ... ## $ modifieddate : POSIXct, format: &quot;2011-06-07&quot; &quot;2011-06-07&quot; ... That’s very simple, but if the table is very large it may not be a problem, since R is designed to keep the entire table in memory. The tables that are found in an enterprise database such as adventureworks may be large, they are most often records kept by people. That somewhat limits their size (relative to data generated by machines) and expands the possibilities for human error. Note that the first line of the str() output reports the total number of observations. Later on we’ll use this tibble to demonstrate several packages and functions, but use only the first 13 columns for simplicity. salesorderheader_tibble &lt;- salesorderheader_tibble[,1:13] 7.2.2 Create a pointer to a table that can be reused The dplyr::tbl function gives us more control over access to a table by enabling control over which columns and rows to download. It creates an object that might look like a data frame, but it’s actually a list object that dplyr uses for constructing queries and retrieving data from the DBMS. salesorderheader_table &lt;- dplyr::tbl(con, &quot;salesorderheader&quot;) class(salesorderheader_table) ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; ## [4] &quot;tbl_lazy&quot; &quot;tbl&quot; 7.2.3 Controlling the number of rows returned with collect() The collect function triggers the creation of a tibble and controls the number of rows that the DBMS sends to R. For more complex queries, the dplyr::collect() function provides a mechanism to indicate what’s processed on on the DBMS server and what’s processed by R on the local machine. The chapter on Lazy Evaluation and Execution Environment discusses this issue in detail. salesorderheader_table %&gt;% dplyr::collect(n = 3) %&gt;% dim() ## [1] 3 25 salesorderheader_table %&gt;% dplyr::collect(n = 500) %&gt;% dim() ## [1] 500 25 7.2.4 Retrieving random rows from the DBMS When the DBMS contains many rows, a sample of the data may be plenty for your purposes. Although dplyr has nice functions to sample a data frame that’s already in R (e.g., the sample_n and sample_frac functions), to get a sample from the DBMS we have to use dbGetQuery to send native SQL to the database. To peek ahead, here is one example of a query that retrieves 20 rows from a 1% sample: one_percent_sample &lt;- DBI::dbGetQuery( con, &quot;SELECT orderdate, subtotal, taxamt, freight, totaldue FROM salesorderheader TABLESAMPLE BERNOULLI(3) LIMIT 20; &quot; ) one_percent_sample ## orderdate subtotal taxamt freight totaldue ## 1 2011-06-22 3578.2700 286.2616 89.4568 3953.9884 ## 2 2011-06-23 3578.2700 286.2616 89.4568 3953.9884 ## 3 2011-06-26 3399.9900 271.9992 84.9998 3756.9890 ## 4 2011-06-28 3578.2700 286.2616 89.4568 3953.9884 ## 5 2011-07-04 3578.2700 286.2616 89.4568 3953.9884 ## 6 2011-07-06 3578.2700 286.2616 89.4568 3953.9884 ## 7 2011-07-19 3578.2700 286.2616 89.4568 3953.9884 ## 8 2011-07-20 3578.2700 286.2616 89.4568 3953.9884 ## 9 2011-07-23 3374.9900 269.9992 84.3748 3729.3640 ## 10 2011-07-31 3374.9900 269.9992 84.3748 3729.3640 ## 11 2011-08-01 6105.3293 584.8735 182.7730 6872.9758 ## 12 2011-08-01 4075.0341 393.8955 123.0923 4592.0219 ## 13 2011-08-01 8129.9760 780.4777 243.8993 9154.3530 ## 14 2011-08-01 16185.4292 1555.4136 486.0668 18226.9096 ## 15 2011-08-16 699.0982 55.9279 17.4775 772.5036 ## 16 2011-08-21 3399.9900 271.9992 84.9998 3756.9890 ## 17 2011-08-22 3578.2700 286.2616 89.4568 3953.9884 ## 18 2011-08-31 31624.7504 3035.8574 948.7054 35609.3132 ## 19 2011-09-04 3399.9900 271.9992 84.9998 3756.9890 ## 20 2011-09-06 3578.2700 286.2616 89.4568 3953.9884 Exact sample of 100 records This technique depends on knowing the range of a record index, such as the businessentityid in the salesorderheader table of our adventureworks database. Start by finding the min and max values. DBI::dbListFields(con, &quot;salesorderheader&quot;) ## [1] &quot;salesorderid&quot; &quot;revisionnumber&quot; ## [3] &quot;orderdate&quot; &quot;duedate&quot; ## [5] &quot;shipdate&quot; &quot;status&quot; ## [7] &quot;onlineorderflag&quot; &quot;purchaseordernumber&quot; ## [9] &quot;accountnumber&quot; &quot;customerid&quot; ## [11] &quot;salespersonid&quot; &quot;territoryid&quot; ## [13] &quot;billtoaddressid&quot; &quot;shiptoaddressid&quot; ## [15] &quot;shipmethodid&quot; &quot;creditcardid&quot; ## [17] &quot;creditcardapprovalcode&quot; &quot;currencyrateid&quot; ## [19] &quot;subtotal&quot; &quot;taxamt&quot; ## [21] &quot;freight&quot; &quot;totaldue&quot; ## [23] &quot;comment&quot; &quot;rowguid&quot; ## [25] &quot;modifieddate&quot; salesorderheader_df &lt;- DBI::dbReadTable(con, &quot;salesorderheader&quot;) (max_id &lt;- max(salesorderheader_df$salesorderid)) ## [1] 75123 (min_id &lt;- min(salesorderheader_df$salesorderid)) ## [1] 43659 Set the random number seed and draw the sample. set.seed(123) sample_rows &lt;- sample(1:max(salesorderheader_df$salesorderid), 10) salesorderheader_table &lt;- dplyr::tbl(con, &quot;salesorderheader&quot;) Run query with the filter verb listing the randomly sampled rows to be retrieved: salesorderheader_sample &lt;- salesorderheader_table %&gt;% dplyr::filter(salesorderid %in% sample_rows) %&gt;% dplyr::collect() str(salesorderheader_sample) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 7 obs. of 25 variables: ## $ salesorderid : int 45404 46435 51663 57870 62555 65161 68293 ## $ revisionnumber : int 8 8 8 8 8 8 8 ## $ orderdate : POSIXct, format: &quot;2012-01-10&quot; &quot;2012-05-06&quot; ... ## $ duedate : POSIXct, format: &quot;2012-01-22&quot; &quot;2012-05-18&quot; ... ## $ shipdate : POSIXct, format: &quot;2012-01-17&quot; &quot;2012-05-13&quot; ... ## $ status : int 5 5 5 5 5 5 5 ## $ onlineorderflag : logi TRUE TRUE TRUE TRUE TRUE FALSE ... ## $ purchaseordernumber : chr NA NA NA NA ... ## $ accountnumber : chr &quot;10-4030-011217&quot; &quot;10-4030-012251&quot; &quot;10-4030-016327&quot; &quot;10-4030-018572&quot; ... ## $ customerid : int 11217 12251 16327 18572 13483 29799 13239 ## $ salespersonid : int NA NA NA NA NA 281 NA ## $ territoryid : int 1 9 8 4 1 4 6 ## $ billtoaddressid : int 19321 24859 19265 16902 15267 997 27923 ## $ shiptoaddressid : int 19321 24859 19265 16902 15267 997 27923 ## $ shipmethodid : int 1 1 1 1 1 5 1 ## $ creditcardid : int 8241 13188 16357 1884 4409 12582 1529 ## $ creditcardapprovalcode: chr &quot;332581Vi42712&quot; &quot;635144Vi68383&quot; &quot;420152Vi84562&quot; &quot;1224478Vi9772&quot; ... ## $ currencyrateid : int NA 4121 NA NA NA NA 11581 ## $ subtotal : num 3578 3375 2466 14 57 ... ## $ taxamt : num 286.26 270 197.31 1.12 4.56 ... ## $ freight : num 89.457 84.375 61.658 0.349 1.424 ... ## $ totaldue : num 3954 3729.4 2725.3 15.4 63 ... ## $ comment : chr NA NA NA NA ... ## $ rowguid : chr &quot;358f91b2-dadd-4014-8d4f-7f9736cb664e&quot; &quot;eb312409-fcd5-4bac-bd3b-16d4bd7889db&quot; &quot;ddc60552-af98-4166-9249-d09d424d8430&quot; &quot;fe46e631-47b9-4e14-9da5-1e4a4a135364&quot; ... ## $ modifieddate : POSIXct, format: &quot;2012-01-17&quot; &quot;2012-05-13&quot; ... 7.2.5 Sub-setting variables A table in the DBMS may not only have many more rows than you want, but also many more columns. The select command controls which columns are retrieved. salesorderheader_table %&gt;% dplyr::select(orderdate, subtotal, taxamt, freight, totaldue) %&gt;% head() ## # Source: lazy query [?? x 5] ## # Database: postgres [postgres@localhost:5432/adventureworks] ## orderdate subtotal taxamt freight totaldue ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2011-05-31 00:00:00 20566. 1972. 616. 23153. ## 2 2011-05-31 00:00:00 1294. 124. 38.8 1457. ## 3 2011-05-31 00:00:00 32726. 3154. 986. 36866. ## 4 2011-05-31 00:00:00 28833. 2775. 867. 32475. ## 5 2011-05-31 00:00:00 419. 40.3 12.6 472. ## 6 2011-05-31 00:00:00 24433. 2345. 733. 27510. That’s exactly equivalent to submitting the following SQL commands directly: DBI::dbGetQuery( con, &#39;SELECT &quot;orderdate&quot;, &quot;subtotal&quot;, &quot;taxamt&quot;, &quot;freight&quot;, &quot;totaldue&quot; FROM &quot;salesorderheader&quot; LIMIT 6&#39;) ## orderdate subtotal taxamt freight totaldue ## 1 2011-05-31 20565.6206 1971.5149 616.0984 23153.2339 ## 2 2011-05-31 1294.2529 124.2483 38.8276 1457.3288 ## 3 2011-05-31 32726.4786 3153.7696 985.5530 36865.8012 ## 4 2011-05-31 28832.5289 2775.1646 867.2389 32474.9324 ## 5 2011-05-31 419.4589 40.2681 12.5838 472.3108 ## 6 2011-05-31 24432.6088 2344.9921 732.8100 27510.4109 We won’t discuss dplyr methods for sub-setting variables, deriving new ones, or sub-setting rows based on the values found in the table, because they are covered well in other places, including: Comprehensive reference: https://dplyr.tidyverse.org/ Good tutorial: https://suzan.rbind.io/tags/dplyr/ In practice we find that, renaming variables is often quite important because the names in an SQL database might not meet your needs as an analyst. In “the wild”, you will find names that are ambiguous or overly specified, with spaces in them, and other problems that will make them difficult to use in R. It is good practice to do whatever renaming you are going to do in a predictable place like at the top of your code. The names in the adventureworks database are simple and clear, but if they were not, you might rename them for subsequent use in this way: tbl(con, &quot;salesorderheader&quot;) %&gt;% dplyr::rename(order_date = orderdate, sub_total_amount = subtotal, tax_amount = taxamt, freight_amount = freight, total_due_amount = totaldue) %&gt;% dplyr::select(order_date, sub_total_amount, tax_amount, freight_amount, total_due_amount ) %&gt;% # head() show_query() ## &lt;SQL&gt; ## SELECT &quot;orderdate&quot; AS &quot;order_date&quot;, &quot;subtotal&quot; AS &quot;sub_total_amount&quot;, &quot;taxamt&quot; AS &quot;tax_amount&quot;, &quot;freight&quot; AS &quot;freight_amount&quot;, &quot;totaldue&quot; AS &quot;total_due_amount&quot; ## FROM &quot;salesorderheader&quot; That’s equivalent to the following SQL code: DBI::dbGetQuery( con, &#39;SELECT &quot;orderdate&quot; AS &quot;order_date&quot;, &quot;subtotal&quot; AS &quot;sub_total_amount&quot;, &quot;taxamt&quot; AS &quot;tax_amount&quot;, &quot;freight&quot; AS &quot;freight_amount&quot;, &quot;totaldue&quot; AS &quot;total_due_amount&quot; FROM &quot;salesorderheader&quot;&#39; ) %&gt;% head() ## order_date sub_total_amount tax_amount freight_amount total_due_amount ## 1 2011-05-31 20565.6206 1971.5149 616.0984 23153.2339 ## 2 2011-05-31 1294.2529 124.2483 38.8276 1457.3288 ## 3 2011-05-31 32726.4786 3153.7696 985.5530 36865.8012 ## 4 2011-05-31 28832.5289 2775.1646 867.2389 32474.9324 ## 5 2011-05-31 419.4589 40.2681 12.5838 472.3108 ## 6 2011-05-31 24432.6088 2344.9921 732.8100 27510.4109 The one difference is that the SQL code returns a regular data frame and the dplyr code returns a tibble. Notice that the seconds are grayed out in the tibble display. 7.3 Translating dplyr code to SQL queries Where did the translations we’ve shown above come from? The show_query function shows how dplyr is translating your query to the dialect of the target DBMS: salesorderheader_table %&gt;% dplyr::tally() %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT COUNT(*) AS &quot;n&quot; ## FROM &quot;salesorderheader&quot; Here is an extensive discussion of how dplyr code is translated into SQL: https://dbplyr.tidyverse.org/articles/sql-translation.html If you prefer to use SQL directly, rather than dplyr, you can submit SQL code to the DBMS through the DBI::dbGetQuery function: DBI::dbGetQuery( con, &#39;SELECT COUNT(*) AS &quot;n&quot; FROM &quot;salesorderheader&quot; &#39; ) ## n ## 1 31465 When you create a report to run repeatedly, you might want to put that query into R markdown. That way you can also execute that SQL code in a chunk with the following header: {sql, connection=con, output.var = &quot;query_results&quot;} SELECT COUNT(*) AS &quot;n&quot; FROM &quot;salesorderheader&quot;; R markdown stores that query result in a tibble which can be printed by referring to it: query_results ## n ## 1 31465 7.4 Mixing dplyr and SQL When dplyr finds code that it does not know how to translate into SQL, it will simply pass it along to the DBMS. Therefore you can interleave native commands that your DBMS will understand in the middle of dplyr code. Consider this example that’s derived from (Ruiz 2019): salesorderheader_table %&gt;% dplyr::select_at(vars(subtotal, contains(&quot;date&quot;))) %&gt;% dplyr::mutate(today = now()) %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT &quot;subtotal&quot;, &quot;orderdate&quot;, &quot;duedate&quot;, &quot;shipdate&quot;, &quot;modifieddate&quot;, CURRENT_TIMESTAMP AS &quot;today&quot; ## FROM &quot;salesorderheader&quot; That is native to PostgreSQL, not ANSI standard SQL. Verify that it works: salesorderheader_table %&gt;% dplyr::select_at(vars(subtotal, contains(&quot;date&quot;))) %&gt;% head() %&gt;% dplyr::mutate(today = now()) %&gt;% dplyr::collect() ## # A tibble: 6 x 6 ## subtotal orderdate duedate shipdate ## &lt;dbl&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;dttm&gt; ## 1 20566. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 2 1294. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 3 32726. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 4 28833. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 5 419. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## 6 24433. 2011-05-31 00:00:00 2011-06-12 00:00:00 2011-06-07 00:00:00 ## # … with 2 more variables: modifieddate &lt;dttm&gt;, today &lt;dttm&gt; 7.5 Examining a single table with R Dealing with a large, complex database highlights the utility of specific tools in R. We include brief examples that we find to be handy: Base R structure: str Printing out some of the data: datatable, kable, and View Summary statistics: summary glimpse in the tibble package, which is included in the tidyverse skim in the skimr package 7.5.1 str - a base package workhorse str is a workhorse function that lists variables, their type and a sample of the first few variable values. str(salesorderheader_tibble) ## &#39;data.frame&#39;: 31465 obs. of 13 variables: ## $ salesorderid : int 43659 43660 43661 43662 43663 43664 43665 43666 43667 43668 ... ## $ revisionnumber : int 8 8 8 8 8 8 8 8 8 8 ... ## $ orderdate : POSIXct, format: &quot;2011-05-31&quot; &quot;2011-05-31&quot; ... ## $ duedate : POSIXct, format: &quot;2011-06-12&quot; &quot;2011-06-12&quot; ... ## $ shipdate : POSIXct, format: &quot;2011-06-07&quot; &quot;2011-06-07&quot; ... ## $ status : int 5 5 5 5 5 5 5 5 5 5 ... ## $ onlineorderflag : logi FALSE FALSE FALSE FALSE FALSE FALSE ... ## $ purchaseordernumber: chr &quot;PO522145787&quot; &quot;PO18850127500&quot; &quot;PO18473189620&quot; &quot;PO18444174044&quot; ... ## $ accountnumber : chr &quot;10-4020-000676&quot; &quot;10-4020-000117&quot; &quot;10-4020-000442&quot; &quot;10-4020-000227&quot; ... ## $ customerid : int 29825 29672 29734 29994 29565 29898 29580 30052 29974 29614 ... ## $ salespersonid : int 279 279 282 282 276 280 283 276 277 282 ... ## $ territoryid : int 5 5 6 6 4 1 1 4 3 6 ... ## $ billtoaddressid : int 985 921 517 482 1073 876 849 1074 629 529 ... 7.5.2 Always look at your data with head, View, or kable There is no substitute for looking at your data and R provides several ways to just browse it. The head function controls the number of rows that are displayed. Note that tail does not work against a database object. In every-day practice you would look at more than the default 6 rows, but here we wrap head around the data frame: sqlpetr::sp_print_df(head(salesorderheader_tibble)) 7.5.3 The summary function in base The base package’s summary function provides basic statistics that serve a unique diagnostic purpose in this context. For example, the following output shows that: * `businessentityid` is a number from 1 to 16,049. In a previous section, we ran the `str` function and saw that there are 16,044 observations in this table. Therefore, the `businessentityid` seems to be sequential from 1:16049, but there are 5 values missing from that sequence. _Exercise for the Reader_: Which 5 values from 1:16049 are missing from `businessentityid` values in the `salesorderheader` table? (_Hint_: In the chapter on SQL Joins, you will learn the functions needed to answer this question.) * The number of NA&#39;s in the `return_date` column is a good first guess as to the number of DVDs rented out or lost as of 2005-09-02 02:35:22. summary(salesorderheader_tibble) ## salesorderid revisionnumber orderdate ## Min. :43659 Min. :8.000 Min. :2011-05-31 00:00:00 ## 1st Qu.:51525 1st Qu.:8.000 1st Qu.:2013-06-20 00:00:00 ## Median :59391 Median :8.000 Median :2013-11-03 00:00:00 ## Mean :59391 Mean :8.001 Mean :2013-08-21 12:05:04 ## 3rd Qu.:67257 3rd Qu.:8.000 3rd Qu.:2014-02-28 00:00:00 ## Max. :75123 Max. :9.000 Max. :2014-06-30 00:00:00 ## ## duedate shipdate status ## Min. :2011-06-12 00:00:00 Min. :2011-06-07 00:00:00 Min. :5 ## 1st Qu.:2013-07-02 00:00:00 1st Qu.:2013-06-27 00:00:00 1st Qu.:5 ## Median :2013-11-15 00:00:00 Median :2013-11-10 00:00:00 Median :5 ## Mean :2013-09-02 12:05:41 Mean :2013-08-28 12:06:06 Mean :5 ## 3rd Qu.:2014-03-13 00:00:00 3rd Qu.:2014-03-08 00:00:00 3rd Qu.:5 ## Max. :2014-07-12 00:00:00 Max. :2014-07-07 00:00:00 Max. :5 ## ## onlineorderflag purchaseordernumber accountnumber customerid ## Mode :logical Length:31465 Length:31465 Min. :11000 ## FALSE:3806 Class :character Class :character 1st Qu.:14432 ## TRUE :27659 Mode :character Mode :character Median :19452 ## Mean :20170 ## 3rd Qu.:25994 ## Max. :30118 ## ## salespersonid territoryid billtoaddressid ## Min. :274.0 Min. : 1.000 Min. : 405 ## 1st Qu.:277.0 1st Qu.: 4.000 1st Qu.:14080 ## Median :279.0 Median : 6.000 Median :19449 ## Mean :280.6 Mean : 6.091 Mean :18263 ## 3rd Qu.:284.0 3rd Qu.: 9.000 3rd Qu.:24678 ## Max. :290.0 Max. :10.000 Max. :29883 ## NA&#39;s :27659 So the summary function is surprisingly useful as we first start to look at the table contents. 7.5.4 The glimpse function in the tibble package The tibble package’s glimpse function is a more compact version of str: tibble::glimpse(salesorderheader_tibble) ## Observations: 31,465 ## Variables: 13 ## $ salesorderid &lt;int&gt; 43659, 43660, 43661, 43662, 43663, 43664, 43… ## $ revisionnumber &lt;int&gt; 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,… ## $ orderdate &lt;dttm&gt; 2011-05-31, 2011-05-31, 2011-05-31, 2011-05… ## $ duedate &lt;dttm&gt; 2011-06-12, 2011-06-12, 2011-06-12, 2011-06… ## $ shipdate &lt;dttm&gt; 2011-06-07, 2011-06-07, 2011-06-07, 2011-06… ## $ status &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… ## $ onlineorderflag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ purchaseordernumber &lt;chr&gt; &quot;PO522145787&quot;, &quot;PO18850127500&quot;, &quot;PO184731896… ## $ accountnumber &lt;chr&gt; &quot;10-4020-000676&quot;, &quot;10-4020-000117&quot;, &quot;10-4020… ## $ customerid &lt;int&gt; 29825, 29672, 29734, 29994, 29565, 29898, 29… ## $ salespersonid &lt;int&gt; 279, 279, 282, 282, 276, 280, 283, 276, 277,… ## $ territoryid &lt;int&gt; 5, 5, 6, 6, 4, 1, 1, 4, 3, 6, 1, 3, 1, 6, 2,… ## $ billtoaddressid &lt;int&gt; 985, 921, 517, 482, 1073, 876, 849, 1074, 62… 7.5.5 The skim function in the skimr package The skimr package has several functions that make it easy to examine an unknown data frame and assess what it contains. It is also extensible. skimr::skim(salesorderheader_tibble) ## Skim summary statistics ## n obs: 31465 ## n variables: 13 ## ## ── Variable type:character ───────────────────────────────────────────────────────────── ## variable missing complete n min max empty n_unique ## accountnumber 0 31465 31465 14 14 0 19119 ## purchaseordernumber 27659 3806 31465 10 13 0 3806 ## ## ── Variable type:integer ─────────────────────────────────────────────────────────────── ## variable missing complete n mean sd p0 p25 ## billtoaddressid 0 31465 31465 18263.15 8210.07 405 14080 ## customerid 0 31465 31465 20170.18 6261.73 11000 14432 ## revisionnumber 0 31465 31465 8 0.031 8 8 ## salesorderid 0 31465 31465 59391 9083.31 43659 51525 ## salespersonid 27659 3806 31465 280.61 4.85 274 277 ## status 0 31465 31465 5 0 5 5 ## territoryid 0 31465 31465 6.09 2.96 1 4 ## p50 p75 p100 hist ## 19449 24678 29883 ▆▁▁▇▇▇▇▇ ## 19452 25994 30118 ▇▆▅▅▃▃▅▇ ## 8 8 9 ▇▁▁▁▁▁▁▁ ## 59391 67257 75123 ▇▇▇▇▇▇▇▇ ## 279 284 290 ▇▆▅▅▃▁▂▅ ## 5 5 5 ▁▁▁▇▁▁▁▁ ## 6 9 10 ▃▁▅▁▃▂▂▇ ## ## ── Variable type:logical ─────────────────────────────────────────────────────────────── ## variable missing complete n mean count ## onlineorderflag 0 31465 31465 0.88 TRU: 27659, FAL: 3806, NA: 0 ## ## ── Variable type:POSIXct ─────────────────────────────────────────────────────────────── ## variable missing complete n min max median ## duedate 0 31465 31465 2011-06-12 2014-07-12 2013-11-15 ## orderdate 0 31465 31465 2011-05-31 2014-06-30 2013-11-03 ## shipdate 0 31465 31465 2011-06-07 2014-07-07 2013-11-10 ## n_unique ## 1124 ## 1124 ## 1124 skimr::skim_to_wide(salesorderheader_tibble) #skimr doesn&#39;t like certain kinds of columns ## # A tibble: 13 x 19 ## type variable missing complete n min max empty n_unique mean ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 char… account… 0 31465 31465 14 14 0 19119 &lt;NA&gt; ## 2 char… purchas… 27659 3806 31465 10 13 0 3806 &lt;NA&gt; ## 3 inte… billtoa… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 1826… ## 4 inte… custome… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 2017… ## 5 inte… revisio… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot; … ## 6 inte… salesor… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot;593… ## 7 inte… salespe… 27659 3806 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot; 2… ## 8 inte… status 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot; … ## 9 inte… territo… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &quot; … ## 10 logi… onlineo… 0 31465 31465 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 0.88 ## 11 POSI… duedate 0 31465 31465 2011… 2014… &lt;NA&gt; 1124 &lt;NA&gt; ## 12 POSI… orderda… 0 31465 31465 2011… 2014… &lt;NA&gt; 1124 &lt;NA&gt; ## 13 POSI… shipdate 0 31465 31465 2011… 2014… &lt;NA&gt; 1124 &lt;NA&gt; ## # … with 9 more variables: sd &lt;chr&gt;, p0 &lt;chr&gt;, p25 &lt;chr&gt;, p50 &lt;chr&gt;, ## # p75 &lt;chr&gt;, p100 &lt;chr&gt;, hist &lt;chr&gt;, count &lt;chr&gt;, median &lt;chr&gt; 7.5.6 Close the connection and shut down adventureworks Where you place the collect function matters. DBI::dbDisconnect(con) sqlpetr::sp_docker_stop(&quot;adventureworks&quot;) 7.6 Additional reading (Wickham 2018) (Baumer 2018) References "]
]
